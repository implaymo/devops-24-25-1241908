# CA1, Part 2: Technical Report : Tutorial application to Gradle

---

## Table of Contents

1. [Introduction](#introduction)
2. [Steps to Follow](#steps-to-follow)
    - [Create a New Branch](#1-create-a-new-branch)
    - [Initialize a Gradle Project](#2-initialize-a-gradle-project)
    - [Extract and Set Up the Project](#3-extract-and-set-up-the-project)
    - [Replace Source Code](#4-replace-source-code)
    - [Run the Application](#5-run-the-application)
    - [Add Frontend Support](#6-add-frontend-support)
    - [Configure Webpack Execution in package.json](#7-configure-webpack-execution-in-packagejson)
    - [Build and Run Application](#8-build-and-run-application)
    - [Automate JAR Deployment](#9-automate-jar-deployment)
    - [Clean Generated Frontend Files](#10-clean-generated-frontend-files)
    - [Testing and Finalization](#11-testing-and-finalization)
    - [Tagging the Repository](#12-tagging-the-repository)
3. [Alternative Solution](#alternative-solution)
    - [Analysis of Alternatives](#analysis-of-alternatives)
    - [Maven vs. Gradle](#maven-vs-gradle)
    - [Why Use Gradle?](#why-use-gradle)
    - [Challenges Faced](#challenges-faced)
4. [Conclusion](#conclusion)

---

### Introduction
This guide focuses on practicing Gradle and creating a Spring Boot application. You will set up and modify a Gradle project, add custom tasks, and integrate unit testing. Key tasks include executing the provided application, adding Gradle tasks for running a server, performing backups, and creating a zip archive. Proper version control practices, including multiple commits, tagging, and using issues, are required.

--- 

### Steps to Follow
1. **Create a New Branch:**
    - Name: `tut-basic-gradle`
    - Checkout the branch and use it for all modifications.

2. **Initialize a Gradle Project:**
    - Use [Spring Initializr](https://start.spring.io) to generate a Gradle-based Spring Boot project.
    - Choose the following requirements:
      - Project:
        - Gradle - Groovy
      - Language: 
        - Java
      - Spring Boot:
        - 3.4.3
      - Packaging:
        - Jar
      - Java:
        - 17
    - Select dependencies:
        - Rest Repositories
        - Thymeleaf
        - JPA
        - H2

3. **Extract and Set Up the Project:**
    - Extract the generated zip into `CA1/Part3/`.
    - Verify available Gradle tasks using `./gradlew tasks`.

4. **Replace Source Code:**
    - Delete the `src` folder from the new project.
    - Copy `src` from the `basic` folder, `webpack.config.js` and `package.json` of [this](https://github.com/spring-attic/tut-react-and-spring-data-rest) tutorial.
    - Delete `src/main/resources/static/built/` (it will be generated via Webpack).

5. **Run the Application:**
    - Execute `./gradlew bootRun`.
    - Observe that `http://localhost:8080` is empty due to missing frontend plugin.

6. **Add Frontend Support:**
- Include the Gradle plugin: `org.siouan.frontend` ([Plugin Documentation](https://github.com/Siouan/frontend-gradle-plugin)).
- Modify `build.gradle` by adding one of the following lines depending on the Java version:
  ```groovy
  id "org.siouan.frontend-jdk8" version "6.0.0"
  id "org.siouan.frontend-jdk11" version "8.0.0"
  id "org.siouan.frontend-jdk17" version "8.0.0"
  ```
- Configure the plugin in `build.gradle`:
  ```groovy
  frontend {
   nodeVersion = "16.20.2"
   assembleScript = "run build"
   cleanScript = "run clean"
   checkScript = "run check"
   packageJsonDirectory = file("${projectDir}")
  }
  ```

7. **Configure Webpack Execution in `package.json`:**
   ```json
   "scripts": {
    "webpack": "webpack",
    "build": "npm run webpack",
    "check": "echo Checking frontend",
    "clean": "echo Cleaning frontend",
    "lint": "echo Linting frontend",
    "test": "echo Testing frontend"
   },
   ```

8. **Build and Run Application:**
    - Execute `./gradlew build`.
    - Run `./gradlew bootRun`.


9. **Automate Jar Deployment:**
    - Add a Gradle task to copy the generated JAR to a `dist` folder at the root level.
   ```groovy
   tasks.register('copyJarToDist', Copy) {
	dependsOn jar
	from jar.archiveFile
	into "${projectDir}/dist"
	doFirst {
		mkdir "${projectDir}/dist"
    }
   }
   ```

10. **Clean Generated Frontend Files:**
    - Create a Gradle task to remove files generated by Webpack (`src/main/resources/static/built/`) and ensure this task runs before `clean`.
    ```groovy
    tasks.register('cleanWebpack', Delete) {
	group = 'build'
	description = 'Deletes all files generated by webpack'
	delete "${projectDir}/src/main/resources/static/built/"
	doFirst {
		println "Cleaning webpack output directory at: ${projectDir}/src/resources/main/static/built/"
        }
    }
    
    tasks.named('clean') {
    dependsOn('cleanWebpack')
    }
    ```

11. **Testing and Finalization:**
    - Experiment with the application and validate all features.
    - Commit changes incrementally.
    - Merge the `tut-basic-gradle` branch into `main`.

13. **Tagging the Repository:**
    - Mark the repository with the tag `ca1-part3` upon completion.
    ```sh
    git tag ca1-part3
    git push origin ca1-part3
    ```
---

## Alternative Solution
This section provides an overview of the conversion from Maven to Gradle and insights into key decisions made.

### Achieving the Same Setup with Maven
To replicate the functionality achieved with Gradle, I explored how to configure Maven for the Spring Boot application. This alternative solution ensures that frontend assets, custom build tasks, and file management are integrated seamlessly within a Maven-based setup. Below is a structured breakdown of how this can be accomplished using Maven.

### Project configuration
A pom.xml file was created to define the project structure, including necessary dependencies for REST, Thymeleaf, JPA, and H2. Here is a key snippet of the dependencies section:
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-rest</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

### Integrating Frontend Support
To enable frontend builds within Maven, I configured the frontend-maven-plugin to manage Node.js, npm installation, and the Webpack build process:
```xml
<plugins>
    <plugin>
        <groupId>com.github.eirslett</groupId>
        <artifactId>frontend-maven-plugin</artifactId>
        <version>1.11.0</version>
        <configuration>
            <nodeVersion>v16.20.2</nodeVersion>
            <workingDirectory>src/main/resources/static</workingDirectory>
        </configuration>
        <executions>
            <execution>
                <id>install-node</id>
                <goals>
                    <goal>install-node-and-npm</goal>
                </goals>
            </execution>
            <execution>
                <id>npm-install</id>
                <goals>
                    <goal>npm</goal>
                </goals>
                <configuration>
                    <arguments>install</arguments>
                </configuration>
            </execution>
            <execution>
                <id>npm-build</id>
                <goals>
                    <goal>npm</goal>
                </goals>
                <configuration>
                    <arguments>run build</arguments>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```
### Automating JAR Deployment
To copy the compiled JAR file to a dist directory, I utilized the maven-resources-plugin:
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-resources-plugin</artifactId>
    <version>3.2.0</version>
    <executions>
        <execution>
            <id>copy-jar</id>
            <phase>package</phase>
            <goals>
                <goal>copy-resources</goal>
            </goals>
            <configuration>
                <outputDirectory>${project.build.directory}/dist</outputDirectory>
                <resources>
                    <resource>
                        <directory>${project.build.directory}</directory>
                        <includes>
                            <include>*.jar</include>
                        </includes>
                    </resource>
                </resources>
            </configuration>
        </execution>
    </executions>
</plugin>
```
### Cleaning Webpack Build Files
To ensure that stale frontend files are removed during the clean process, the maven-clean-plugin was customized:
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-clean-plugin</artifactId>
    <version>3.1.0</version>
    <executions>
        <execution>
            <id>delete-webpack-files</id>
            <phase>clean</phase>
            <goals>
                <goal>clean</goal>
            </goals>
            <configuration>
                <filesets>
                    <fileset>
                        <directory>src/main/resources/static/built</directory>
                        <includes>
                            <include>*</include>
                        </includes>
                    </fileset>
                </filesets> 
            </configuration>
        </execution>
    </executions>
</plugin>
```
### Maven vs. Gradle: A Comparative Analysis
To make an informed decision on whether to use Maven or Gradle, I analyzed their core characteristics in the following comparison:

| Feature            | Maven                                      | Gradle                                      |
|--------------------|-------------------------------------------|---------------------------------------------|
| **Build Language** | XML-based (`pom.xml`)                     | Uses Groovy/Kotlin DSL (`build.gradle`)     |
| **Performance**    | Sequential execution, slower builds       | Incremental builds for better performance  |
| **Flexibility**    | Strict lifecycle phases, less adaptable   | Highly customizable with scripting         |
| **Dependency Management** | Centralized repository system | Advanced dependency resolution |
| **Ease of Use**    | Standardized and predictable              | More flexible but has a learning curve     |
| **Plugins**        | Well-documented but rigid                 | Extensive, easier to customize             |
| **Community Support** | Large, well-established ecosystem   | Growing adoption with strong support       |

---

# Conclusion

Switching from Maven to Gradle enhanced build automation, streamlined dependency management, and improved flexibility. Gradle’s scripting capabilities and frontend integration simplified the workflow, making it a strong choice for modern development. This experience reinforced the importance of selecting the right build tool based on project needs and team expertise.



